# Automation-using-Python
Concurrency and threads are defined and the general idea is described.  The fundamental background and programming concepts for multi-threaded / concurrent programming is explained.
The Python script shows how to create simple threads. Here, threads are used to concurrently read from various files and count the number of words within. Material leading up to example3.py discuss the main problems with threads, which is shared resources get corrupted due to a situation known as a race condition. 
To combat the issue of race conditions and to synchronize access to shared resources, the concept of locks is discussed and illustrated. Finally, a lingering issue remains: avoiding deadlocks. Material leading up to example5.py discuss this concept and the Python script.
Discussing the reasoning behind using a try-finally block in your code when implementing locks. So that multiple threads do not corrupt a shared resource when they are using it (due to a race condition), we have to synchronize access to this shared resource. In order to do this, lock objects are introduced. A lock object is used to control threads that manipulate a shared resource by only allowing one thread at a time to access the shared resource. Which thread? The one that owns the lock. Once a particular thread has “acquired” the lock, no other thread can obtain the lock, and therefore, no other thread can have access to the shared resource. As soon as the thread is done with the shared resource, it can “release” the lock, allowing another thread waiting to use that same resource to acquire the lock and have access to the shared resource. In the code itself, the code that manipulates the shared resource is surrounded by calls to “acquire” (lock) and “release” (unlock) the lock. A problem arises if an exception is thrown after the lock is acquired. Control is immediately transferred to an exception handler once an exception is thrown, and the code doesn’t resume where it left off. Therefore, there is no mechanism to release the lock! This means the thread that had an exception owns the lock indefinitely, and the program is deadlocked because no other thread can gain the lock to access the shared resource since that thread would never be able to execute the line of code that unlocks the lock! The solution is implementing a try-finally block. This video will explain how implementing a try-finally block is a solution to this problem.
